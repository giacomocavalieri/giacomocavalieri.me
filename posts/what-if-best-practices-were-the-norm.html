<!doctype html>
<html lang="en"><head><title>What if best practices were the norm?</title><meta charset="utf-8"><meta content="width=device-width, initial-scale=1.0, viewport-fit=cover" name="viewport"><link href="https://giacomocavalieri.me/feed.xml" rel="alternate" title="giacomocavalieri.me posts feed" type="application/rss+xml"><meta content="Giacomo Cavalieri&#39;s blog" property="og:site_name"><meta content="What if best practices were the norm?" property="og:title"><meta content="website" property="og:type"><meta content="During my second year of university I followed a course dedicated to object-oriented programming and quickly fell in love with Java. My honeymoon phase with it is long over and I&#39;ve come to dislike a lot of the ceremonies and self-imposed restrictions that can come with good object-oriented code. So  what if the best practices I&#39;m forcing myself to follow were easier to adopt and put into practice?" property="og:description"><meta content="During my second year of university I followed a course dedicated to object-oriented programming and quickly fell in love with Java. My honeymoon phase with it is long over and I&#39;ve come to dislike a lot of the ceremonies and self-imposed restrictions that can come with good object-oriented code. So  what if the best practices I&#39;m forcing myself to follow were easier to adopt and put into practice?" name="description"><meta content="summary" property="twitter:card"><meta content="What if best practices were the norm?" property="twitter:title"><meta content="During my second year of university I followed a course dedicated to object-oriented programming and quickly fell in love with Java. My honeymoon phase with it is long over and I&#39;ve come to dislike a lot of the ceremonies and self-imposed restrictions that can come with good object-oriented code. So  what if the best practices I&#39;m forcing myself to follow were easier to adopt and put into practice?" property="twitter:description"><meta content="@giacomo_cava" property="twitter:creator"><link as="font" crossorigin="true" href="Mona-Sans.woff2" rel="payload" type="font/woff2"><meta content="#cceac3" media="(prefers-color-scheme: light)" name="theme-color"><link href="/style.css" rel="stylesheet"><script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.11.1/languages/diff.min.js"></script><script src="/highlightjs-gleam.js"></script><script>hljs.highlightAll();</script></head><body><div class="limit-max-width-and-center"><article class="post h-entry "><header><h1 class="post-title p-name ">What if best practices were the norm?</h1><nav class="breadcrumbs"><a class="breadcrumb-link" href="/" rel="author">← home</a></nav><div class="post-subtitle"><time class="post-date dt-published " datetime="2024-02-26">26 February 2024</time><ul class="post-tags"><li class="post-tag p-category "><a href="/tags/fp.html">fp</a></li><li class="post-tag p-category "><a href="/tags/gleam.html">gleam</a></li></ul></div></header><main class="post-body e-content "><blockquote><p>For my Italian speakers, there&#39;s also a
<a href="https://youtu.be/PpasgrDsKis?si=Tq_zt3jJ_KGH1lsv">video recording</a>
of a talk I did about the same topic.
If you prefer listening to stuff you might enjoy it!</p></blockquote><p>During my second year of university I followed an amazing course dedicated to
object-oriented programming, held by one of the best professors I&#39;ve
ever had the pleasure to meet. It focused not only on the language in itself
– Java, in this case – but also on the <em>best practices</em> we ought to follow to
make code easier to refactor and reason about.
To me, a freshman who only knew C, that felt almost like magic and I quickly
fell in love with Java.</p><p>Quite a few years have passed since then, and my honeymoon phase with Java is
long over. As I learned new languages and grew as a developer, I&#39;ve come to
dislike a lot of the ceremonies and self-imposed restrictions that can come with
good object-oriented code.</p><p>What if the best practices I&#39;m forcing myself to follow (with good reason, don&#39;t
get me wrong!) were easier to adopt and put into practice? Heck, what if they
were <em>the only way</em> to write code and not some rule that could be ignored?</p><p><em>What if best practices were the norm?</em></p><h2 id="Lies-lies-lies">Lies, lies, lies</h2><p>Java is a powerful language that gives us a lot of room to write clean,
expressive code.
However, with great power comes great responsibility and we have to learn that
even some of the core features of the language can turn into a footgun if not
used with great care.
That&#39;s why we need some rules to constrain ourselves and make sure our programs
will be well-behaved under all circumstances.</p><p>Take for example null references, the bane of every Java programmer&#39;s
existence. Every time we return <code>null</code> from a method we are condemning another
programmer – or our future selves – to deal with a much dreaded
<code>NullPointerException</code>.</p><p>The problem is that <code>null</code>s are a sneaky way for our methods to <em>lie</em> about
their actual behaviour. To see what I mean by that, let&#39;s look at an example:</p><pre><code class="not-prose language-java hljs" data-lang="java">class User {
  // For this super simple example a User just has an id and a name
  public final int id;
  public final String name;

  public User(final int id, final String name) {
    this.id = id;
    this.name = name;
  }

  public static User load(int id) {
    // ...
  }
}
</code></pre><p>The implementation of <code>load</code> is not important, and it shouldn&#39;t be!
This method may fetch a user from a database, an in-memory store, or somewhere
else entirely.
The point is we don&#39;t want to go and dive into the implementation of every
method we use.
To me, that&#39;s where the beauty of static types lies: just by reading the
signature of a method we can get a pretty good hunch of what to expect.</p><p>So, what is <code>load</code>&#39;s signature telling us?
&quot;Give me an int and I&#39;ll get you a <code>User</code>&quot;
Great! Let&#39;s put it to good use and do something useful:</p><pre><code class="not-prose language-java hljs" data-lang="java">class Main {
  public static void main(String[] args) {
    User user = User.load(1);
    System.out.println(&quot;The user with id 1 has name &quot; + user.name);
  }
}
</code></pre><p>A seasoned Java developer might already have spotted the myriad of ways in
which this seemingly harmless snippet of code could fail: if <code>load</code> returns a
null reference or throws a runtime exception our code will crash at runtime.
But how am I expected to know that when the method is lying about its behaviour?
It says that it returns a <code>User</code> when in fact it might return a null reference
or just crash with an exception and return nothing at all!</p><p>We have to <em>remember</em> to check for null references and catch possible
exceptions:</p><pre><code class="not-prose language-java hljs" data-lang="java">class Main {
  public static void main(String[] args) {
    try {
      User user = User.load(1);
      if (user != null) {
        System.out.println(&quot;The user with id 1 has name &quot; + user.name);
      } else {
        System.out.println(&quot;There&#39;s no user with id 1&quot;);
      }
    } catch {
      System.out.println(&quot;Error loading the user with id 1&quot;);
    }
  }
}
</code></pre><p>The crux of the problem is that <em>nothing forced me to add any checks!</em> I had to
be diligent and remember to add those. The easy thing to do – simply accessing
the name property of the user, disregarding any possible check – is not the
correct one!
It follows that forgetting to add a null check or a try-catch is bound to
happen; it&#39;s not a matter of <em>if</em>, but <em>when:</em> developers can be in a rush,
have tight deadlines, or simply be tired after many hours in front of a screen!</p><h3 id="Gleam-to-the-rescue">Gleam to the rescue</h3><p>What if, instead of having to be always on the lookout, the language could
make sure that no function failure could go undetected? That sounds almost too
good to be true but as it turns out, not only is this possible, but it&#39;s also
easier than you might expect!</p><p>Enters <a href="https://gleam.run">Gleam</a>: a friendly, simple, and pragmatic programming
language that, among other things, has no runtime exceptions or null pointers!
Let&#39;s see how the example I showed you earlier in Java might look in Gleam:</p><pre><code class="not-prose language-gleam hljs" data-lang="gleam">type User {
  // For this super simple example a User just has an id and a name
  User(id: Int, name: String)
}
</code></pre><p>With this definition we&#39;re creating a <code>User</code> type and saying that users only
have two fields called &quot;id&quot; and &quot;name&quot; with types <code>Int</code> and <code>String</code>.
We could define a couple of users like this:</p><pre><code class="not-prose language-gleam hljs" data-lang="gleam">pub fn main() {
  let rob = User(1, &quot;Rob&quot;)
  let ben = User(2, &quot;Ben&quot;)
}
</code></pre><blockquote><p>As you might have noticed, keywords aside, this is not extremely different
from the Java version, there&#39;s no <code>new</code> keyword to create things and you might
be wondering where all the getters and setters have gone.
Bear with me, we&#39;ll get to that later.</p></blockquote><p>And now onto the most important piece: the function to load users; as usual
we don&#39;t care about its implementation, with a quick look at its type we can
already discover what matters most.</p><pre><code class="not-prose language-gleam hljs" data-lang="gleam">pub fn load(id: Int) -&gt; Result(User, Nil) {
  //                 ^^ the return type of the function
  //                    comes after this arrow
  // ...
}
</code></pre><p>The function doesn&#39;t simply return a <code>User</code> but a special type: a <code>Result</code>.
What does it mean? In case everything goes right the function is going to return
a user, as expected. However, in case something goes wrong we&#39;re getting a <code>Nil</code>
instead. So the function can still fail (and it will) but it&#39;s impossible to
forget about it! A <code>Result</code> acts as a glaring and <em>unmistakable sign</em> that
things might not turn out as expected.</p><p>The invaluable advantage this approach gives us is that we&#39;re no longer on our
own when performing error checking. The compiler can now point out every single
piece of code where things might fail that we forgot to check.
It&#39;s like having <em>a friendly programmer by our side who never gets tired</em>; they
can point to all of our pieces of code that, if not taken care of, might turn
into runtime exceptions. Let&#39;s see what happens if we&#39;re not careful with the
<code>load</code> function:</p><pre><code class="not-prose language-gleam hljs" data-lang="gleam">// This is how you define the main in Gleam
pub fn main() {
  let user = load(1)
  io.println(&quot;The user with id 1 has name &quot; &lt;&gt; user.name)
  //                                               ^^^^^
  // This field does not exist.
  // The value being accessed has this type:
  //
  //     Result(User, Nil)
  //
  // It does not have any fields.
}
</code></pre><p>The code won&#39;t even compile! We&#39;re trying to treat a <code>Result</code> like a <code>User</code> but
that&#39;s not possible, since a call to <code>load</code> might have failed. Compare this with
the Java example I showed you earlier, where the compiler would gladly accept
our code even though it could result in a runtime exception.</p><h3 id="Pattern-matching-or-the-superpower-of-functional-programming">Pattern matching, or the superpower of functional programming</h3><p>How can we get a user out of a <code>Result</code>, then? That can be achieved with
<em>pattern matching.</em> To get the previous broken code snippet to compile we can do
something like this:</p><pre><code class="not-prose language-gleam hljs" data-lang="gleam">pub fn main() {
  case load(1) {
    Ok(user) -&gt; io.println(&quot;The user with id 1 has name &quot; &lt;&gt; user.name)
    Error(Nil) -&gt; io.println(&quot;There&#39;s no user with id 1&quot;)
  }
}
</code></pre><p>Pattern matching allows you to check the shape of data; in this case, we can
take different actions based on the result of the loading function: if
everything went smoothly we will have a user in the <code>Ok</code> branch.
Once again, we will never forget that a user can be missing because we&#39;re forced
to deal with the <code>Error</code> branch as well.
But what if we wanted to deal with more complex errors?
A user might be missing, or there could be problems with the connection to the
database (if we&#39;re fetching users from there)…
just getting a generic <code>Error(Nil)</code> won&#39;t cut it.</p><p>Luckily it&#39;s extremly easy to change the code, first of all we need a new type
to describe the possible errors that may take place:</p><pre><code class="not-prose language-gleam hljs" data-lang="gleam">pub type LoadError {
  UserNotFound
  ConnectionError
}
</code></pre><p>Now the function can return a specific error in case something goes wrong.</p><pre><code class="not-prose language-gleam hljs" data-lang="gleam">pub fn load(id: Int) -&gt; Result(User, LoadError) {
  // ...
}
</code></pre><p>Notice how the function is now saying that it will return a more specific
<code>LoadError</code> in case something goes wrong; that can be fundamental to deal with
different failures in different ways.
After this refactor we will be forced by the compiler to deal with every single
error that may occur in the function, luckily that&#39;s as simple as adding a new
branch to our previous pattern matching:</p><pre><code class="not-prose language-gleam hljs" data-lang="gleam">pub fn main() {
  case load(1) {
    Ok(user) -&gt; io.println(&quot;The user with id 1 has name &quot; &lt;&gt; user.name)
    Error(UserNotFound) -&gt; io.println(&quot;There&#39;s no user with id 1&quot;)
    Error(ConnectionError) -&gt; io.println(&quot;There was a connection error!&quot;)
  }
}
</code></pre><blockquote><p>Being able to deal with errors like this is incredibly powerful, we do not
have to add new ad-hoc contructs to the languaguage like try-catch blocks.
One of the design goals of Gleam is to be simple, it doesn&#39;t even have if
statements, it does everything through pattern matching!
If you&#39;re curious to learn more about Gleam&#39;s syntax Erika Rowland wrote a
great blog post about it,
<a href="https://erikarow.land/notes/gleam-syntax">do check it out!</a></p></blockquote><h3 id="Correct-made-easy">Correct made easy</h3><p>Let&#39;s take a second to appreciate this: by forcing a function to be explicit
about the fact that it can fail we no longer have to rely on &quot;best practices&quot;
(never return null references, don&#39;t use exceptions as a control flow mechanism,
remember to check if objects coming from other functions are null, so on and so
forth).
<em>The easy thing to do is also the right one</em> because that&#39;s the only way to
write code!</p><p>A beginner who&#39;s just started to learn Gleam won&#39;t see mysterious
runtime exceptions popping up in their fun learning project just because they
didn&#39;t know a slew of unwritten rules people are expected to know.
An experienced Java developer won&#39;t have to waste time trying to trace back
where that pesky <code>null</code> came from because a <code>NullPointerException</code> was reported
in production.</p><p>A program won&#39;t crash at runtime because it&#39;s impossible for an error to go
undetected.
And, as I hope you might have noticed, the language doesn&#39;t have to be complex
to give you these guarantees! On the contrary, it makes things easier: there&#39;s
only one control flow mechanism – pattern matching – and you don&#39;t have to
juggle between if statements and try-catch blocks to deal with all the possible
ways a method might lie.</p><blockquote><p>**Addendum: what about <code>Optional</code>?**</p><p>After posting this online I received some great feedback: people pointed that
one could use Java&#39;s <code>Optional</code> to help avoid <code>null</code>s. That&#39;s a good point!
<code>Optional</code> is a life saver and I always rely on it when writing Java code.
My point still stands: <em>deciding to use it is a best practice</em>,
it&#39;s not the only possible way to write Java code that deals with missing
values.</p><p>It can only give us some safety if we&#39;re diligent and use it properly,
remember this is still perfectly valid Java code:</p><pre><code class="not-prose language-java hljs" data-lang="java">public static Optional&lt;User&gt; load(int id) {
  return null;
  // Optional is an object after all!
}
</code></pre><p>
To add to the point, it&#39;s not that beginner friendly: I&#39;ve been a teaching
assistant for a couple of years now, and I&#39;ve lost count of the number of
students trying to do this:</p><pre><code class="not-prose language-java hljs" data-lang="java">Optional.of(someObject)
</code></pre><p>
Can you spot the bug? If <code>someObject</code> is <code>null</code> this will still result in a
<code>NullPointerException</code>! These are bright students and have been taught that
the proper way to do that is using <code>Optional.ofNullable</code>, they&#39;ve even been
shown examples doing it.
But <em>there&#39;s only so many rules that one can remember to apply off the top their head</em>
and this is such an easy mistake that I see it regularly in students&#39; code.</p></blockquote><h2 id="Beware-of-mutable-data">Beware of mutable data</h2><p>When learning Java our teacher really drilled into us a rule of thumb to always
follow: <em>always favour immutable data structures,</em> when defining a class
always make its fields <code>final</code>.</p><p>This is great advice! Removing the final annotation should only be used as a
last resort. The rationale behind this practice is that having immutable data
structures can make it easier to refactor and reason about code.</p><p>Over-relying on mutable state can quickly turn into an headache. Imagine users
can now store their own birthday:</p><pre><code class="not-prose language-java hljs" data-lang="java">class User {
  public final int id;
  public final String name;
  public final Date birthday;

  public User(final int id, final String name, final Date birthday) {
    this.id = id;
    this.name = name;
    this.birthday = birthday;
  }

  // ...
}
</code></pre><p>Since all the user&#39;s fields are <code>final</code> we can be sure that whoever is going to
get a hold of a reference to a user is not going to be able to modify it:</p><pre><code class="not-prose language-java hljs" data-lang="java">User user = User.load(1);
user.id = 12;
// This is a compile time error, nice!
</code></pre><p>Beware! We&#39;re still not completely safe from some mutability-related bugs.
We have to remember that <code>Date</code> is a <em>mutable</em> data structure: whoever gets a
hold of a user might not be able to change its id or name, but can do whathever
they want with their birthday.</p><pre><code class="not-prose language-java hljs" data-lang="java">User user = User.load(1);
user.birthday.setYear(1900);
</code></pre><p>And now, all of a sudden, we have a really old user! Since mutation can happen
anywhere, it can be incredibly hard to trace back to the source of the problem
and might require quite the debugging ability – and I, for one, don&#39;t have it.</p><h3 id="A-web-of-dependencies">A web of dependencies</h3><p>An even hairier problem arise when we start sharing mutable data:</p><pre><code class="not-prose language-java hljs" data-lang="java">Date birthday = new Date(1998, 10, 11)
User jak = new User(1, &quot;Jak&quot;, birthday)
User tom = new User(1, &quot;Tom&quot;, birthday)
//   ^^^ That&#39;s my twin!
</code></pre><p>We&#39;re passing around two references to a single heap-allocated object.
Now if one of the two users tries and change its birthday the same change will
reflect on the other one, that&#39;s some spooky action at a distance!</p><p>And now since there&#39;s more places that rely and can change that same value, the
order with which we call our functions becomes crucial:</p><pre><code class="not-prose language-java hljs" data-lang="java">jak.isOver18() // -&gt; true
tom.birthday.setYear(2010);
jak.isOver18() // -&gt; false
</code></pre><p>We might end up breaking some invariants by simply moving a line of code
around, talk about fiddly! We are caught in a web of invisible dependencies
threaded throughout every method call: the order of every single method call
that takes as input a mutable object is important!
A strong testing suite can really help us giving confidence that our
innocent-looking refactoring didn&#39;t actually break some important properties –
easier said than done!</p><p>Is there a way out? Sort of. We can make our best to encapsulate the state of
objects and never leak references to objects we don&#39;t want others to change:</p><pre><code class="not-prose language-java hljs" data-lang="java">class User {
  private final Date birthday;

  public User(final int id, final String name, final Date birthday) {
    this.id = id;
    this.name = name;
    this.birthday = new Date(birthday);
    //              ^^^^^^^^^^^^^^^^^^ Here we&#39;re making a defensive copy
  }

  public Date getBirthday() {
    return new Date(this.birthday);
    //     ^^^^^^^^^^^^^^^^^^^^^^^^ We return a copy of the user&#39;s birthday
  }

  // ...
}
</code></pre><p>By storing and returning copies we&#39;re making sure that no one can put their
hands on the user&#39;s birthday. Mutation can now happen in a single place – the
<code>User</code> class – and can be tamed much more easily.</p><h3 id="Making-best-practices-the-rules-of-the-game">Making best practices the rules of the game</h3><p>Our naïve attempt at writing a <code>User</code> class was riddled with small problems and
endless possible sources of bugs. Once again, we had to
<em>be careful and remember</em> to always store and return copies of potentially
mutable data, effectively making it immutable.</p><p><em>If making things immutable is desirable why not make it the default?</em>
This is another great example of turning a best practice into the only possible
way to write code. If making things immutable has so many advantages let&#39;s make
it the only possible way to do things! Every data structure defined in Gleam is
immutable by default:</p><pre><code class="not-prose language-gleam hljs" data-lang="gleam">let birthday = Date(1998, 10, 11)
let jak = User(1, &quot;Jak&quot;, birthday)
let tom = User(1, &quot;Tom&quot;, birthday)
</code></pre><p>Is it safe to share the same <code>birthday</code> here, or are we bound to run into the
same issues we found in the corresponding Java version? Since everything is
immutable we can answer with peace of mind: <em>yes, it&#39;s safe!</em>
Let&#39;s appreciate how we now have one less thing to constantly worry about.</p><blockquote><p><em>&quot;But how can I do anything useful if I can&#39;t mutate data?&quot;</em> I hear you cry.
You&#39;re right, you can&#39;t write a program the same way you would if you could
mutate data; you can&#39;t even have a <code>for</code> loop – after all, even increasing a
loop counter counts as mutation and that&#39;s not allowed.</p><p>It can require some getting used to at first but trust me, it&#39;s absolutely
possible to write useful programs even if you can&#39;t mutate stuff.
For now I&#39;ll just focus on the advantages this approach gives us and
I&#39;m not going to explain <em>how</em> to program with immutable data. That might be
worthy of a blog post of its own in the future.</p></blockquote><h2 id="The-art-of-code-formatting">The art of code formatting</h2><p>Learning a programming language is only a small part of the picture, though.
As developers, we also have to rely on a variety of tool: linters, formatters,
build tools, and the list could go on.
For this blog post I&#39;ll focus on my favourite one: formatters.</p><h3 id="Consistency-is-key">Consistency is key</h3><p>I&#39;ve never understood people who claim that programming is boring. Personal
taste, creativity and imagination play such an important role in coding that if
you ask a thousand developers to implement the same algorithm you&#39;ll probably
get a thousand of different answers.</p><p>That&#39;s the beauty of programming – and what made me fall in love with it in the
first place. However, it can also turn into an endless source of teeth grinding
when working with other developers: we all have different tastes and everyone
will push for their own style to be adopted. Take this small snippet of code,
there&#39;s probably a million different ways it could be formatted:</p><pre><code class="not-prose language-gleam hljs" data-lang="gleam">case user {
  User(_id, &quot;Giacomo&quot;, _birthday) -&gt; io.println(&quot;Hello, Giacomo&quot;)
  User(_) -&gt; io.println(&quot;Wait, who are you?&quot;)
}
</code></pre><p>What if we want to vertically align the <code>case</code>&#39;s arrows?</p><pre><code class="not-prose language-gleam hljs" data-lang="gleam">case user {
  User(_id, &quot;Giacomo&quot;, _birthday) -&gt; io.println(&quot;Hello, Giacomo&quot;)
  User(_)                         -&gt; io.println(&quot;Wait, who are you?&quot;)
}
</code></pre><p>Mmh or maybe we could separate each <code>case</code> branch with a newline to make code
breathe a bit better:</p><pre><code class="not-prose language-gleam hljs" data-lang="gleam">case user {
  User(_id, &quot;Giacomo&quot;, _birthday) -&gt; io.println(&quot;Hello, Giacomo&quot;)

  User(_) -&gt; io.println(&quot;Wait, who are you?&quot;)
}
</code></pre><p>We could even decide to put what comes after the arrow on its own line:</p><pre><code class="not-prose language-gleam hljs" data-lang="gleam">case user {
  User(_id, &quot;Giacomo&quot;, _birthday) -&gt;
    io.println(&quot;Hello, Giacomo&quot;)

  User(_) -&gt;
    io.println(&quot;Wait, who are you?&quot;)
}
</code></pre><p>I could go on for days adding small tweaks to the look of this bit of code.
And it can be quite a fun exercise! Finding the best looking possible solution
is really satisfying after all – and I love doing that from time to time.</p><p>The point is that we want to avoid these kind of inconsitencies in style at all
costs when working with other people: imagine having a codebase where sometimes
things get indented with two spaces, and sometimes with four! So, in order to
enforce a single style we rely on formatters: a nifty tool take ingests your
code and spits it out it in a pretty format with consistent style.</p><blockquote><p>I can&#39;t express how much I love formatters, most of my contributions to the
Gleam compiler are in its formatter and I even wrote a pretty printing package
in Gleam, if you&#39;re curious to learn how formatting works I can recommend
reading <a href="https://hexdocs.pm/glam/">its docs</a>, it&#39;s full of examples!</p></blockquote><h3 id="Finding-the-perfect-style">Finding the perfect style</h3><p>Formatters usually come with some levers you can pull to tweak the final look
of your code: decide how many spaces the indentation is, wether to remove
trailing commas, vertically align arrows and variables…
the possibilities are endless.</p><p>Back in my university days I remember doing a group project with three friends
in Scala. We decided to use <a href="https://scalameta.org/scalafmt/">scalafmt</a>, a
formatter that comes with more than 70 (I started counting and then got
tired) such levers. I had the greatest fun reading through the documentation
and discovering all choices I could make; needless to say, we spent
<em>way too much time</em> trying to agree on the final style.</p><h3 id="No-bikeshedding-allowed-here">No bikeshedding allowed here</h3><p>Sometimes having too much freedom can be counter productive. Having a
configurable formatter can have some drawbacks: first of all you&#39;ll have to
take your time to decide the formatter configuration, decision fatigue anyone?
And then what happens if the configuration doesn&#39;t fit one&#39;s tastes? Knowing
that it can be changed will inevitably lead to someone proposing to change it!
What&#39;s worse is that different projects will most likely have different styles.</p><p>Gleam does something really cool in my opinion: the language comes with a
built-in formatter with <em>zero configuration.</em> Loosing the ability to tweak the
output of the formatter has some nice consequences: first of all, it&#39;s
impossible to lose time bikeshedding. All choices about the look of Gleam code
are taken by the language, developers won&#39;t ever have to worry about it (and
if the formatter is good enough, will probably never feel this is a limitation).</p><p>What&#39;s most important is that every single Gleam project
<em>will have a nice and familiar look.</em> Once again, there&#39;s one less thing to
worry about!</p><h2 id="TL;DR">TL;DR</h2><p>Writing code is hard, <em>writing good code is even harder.</em> That&#39;s why, when
learning a new programming language like Java, we also have to learn a slew of
&quot;best practices&quot;. That might require a lot of effort and discipline, but will
help us avoid a lot of common pitfalls that countless other developers have
fallen into before us.</p><p>The problem with best practices is that those are… well, just practices.
Nothing is forcing us to follow those, and having a rule that can be ignored is
like having no rule at all! To cite just one example: null pointers and
unchecked exceptions are the bane of every Java programmer. We know how tricky
those are and strive to avoid using those, yet everyone will have encountered
the dreaded <code>NullPointerException</code> at least once in their Java programming
carreer.
As programmers we&#39;re <em>incredibly good at ignoring the million possible ways in which our code can fail</em> and will eventually forget a null check or a <code>try</code>.</p><p>A language like Gleam takes a radically different approach by making best
practices the norm. <code>null</code> is bad? <em>Get rid of it.</em>
Exceptions are a pain to deal with? <em>Make sure the compiler helps us out.</em>
Mutability leads to brittle code that&#39;s harder to refactor? <em>Make everything immutable.</em>
Having a configurable formatter leads to bikeshedding and decision fatigue? <em>Get rid of the configuration.</em></p><p>The language only shows you a single, well-defined path: it gently pushes you
into a <em>pit of succes,</em> instead of dropping you in the middle of a maze of
choices and unwritten rules.</p><p>A beginner will find a welcoming language where it&#39;s harder to mess up simple
stuff while the experienced developer will enjoy the productivity and peace of
mind of not having to worry about a million different pitfalls.</p><hr><p>Phew, that was quite long! I hope you enjoyed this article as much as I&#39;ve
enjoyed writing it. I hope you&#39;ll be around for the next one!</p></main></article></div></body></html>