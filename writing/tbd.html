<!doctype html>
<html lang="en"><head><title>TBD</title><meta charset="utf-8"><meta content="width=device-width, initial-scale=1.0, viewport-fit=cover" name="viewport"><link href="https://giacomocavalieri.me/feed.xml" rel="alternate" title="giacomocavalieri.me posts feed" type="application/rss+xml"><link href="favicon.ico" rel="icon" type="image/x-icon"><meta content="Giacomo Cavalieri" property="og:site_name"><meta content="TBD" property="og:title"><meta content="website" property="og:type"><meta content="https://giacomocavalieri.me/imgs/og-preview-image.jpg" property="og:image"><meta content property="og:description"><meta content name="description"><link href="/style-6.css" rel="stylesheet"><script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.11.1/languages/diff.min.js"></script><script src="/highlightjs-gleam.js"></script><script>hljs.highlightAll();</script></head><body class="stack-l"><ol aria-label="Breadcrumb" class="breadcrumb"><li><a href="/">home</a></li><li><a href="/writing.html" style="view-transition-name:writing-animation;">writing</a></li><li><h2 aria-current="page" data-crumb="block">TBD</h2></li></ol><main class="stack article"><section class="stack"><p>Writing tests is boring.
Even worse, maintaining tests is boring <em>and</em> error prone.
The tragedy is they&#39;re also one of the most valuable pieces of code we could
write.
So let me show you a fun technique to add to your testing toolbox that can make
writing and maintaining tests a whole lot more pleasant.
This technique is applicable everywhere, and we&#39;ll go through real-world
examples, ranging from compilers written in Rust, to web animation libraries,
to… chess engines!</p></section><section class="stack"><h2 id="The-problem">The problem</h2><p>Say you&#39;re writing a cool command line application, maybe it&#39;s just a little
internal helper to be used to automate some tedious chores, or maybe it&#39;s a cool
open source project.
What&#39;s the most important part of this application?
<em>The help text!</em>
That&#39;s what users will look at when they&#39;re lost, so it&#39;s crucial to get it
right.
Does this ring a bell?
Since it&#39;s so important we should be testing it:</p><pre><code class="not-prose language-gleam hljs" data-lang="gleam">pub fn help_text_test() {
  assert cli.help_text() == &quot;
usage: lucysay [-m message] [-f file]

  -m, --message  the message to be printed
  -f, --file     a file to read the message from
  -h, --help     show this help text
&quot;
}
</code></pre><p>We&#39;re checking the help text string conforms to an expected message, since we&#39;re
writing a regular unit test assertion there&#39;s no escaping it: we have to type
that in full.</p><p>What&#39;s worse is, if the help text changes (say we&#39;re shipping a v2 with more
flags and features) we&#39;ll have to go through that literal string and manually
fix it to make sure the test is now passing. This is quite the tedious chore!
Writing and maintaining these kind of tests, with wordy assertions, is never
fun: it&#39;s a boring, repetitive, and error-prone process.</p><blockquote class="stack"><p>Possibly a note on why generating the asserted value is not a wise choice
wibble wobble</p></blockquote></section><section class="stack"><h2 id="Snapshot-testing-to-the-rescue">Snapshot testing to the rescue</h2><p>Here&#39;s were snapshot testing comes into play.
The elevator pitch is simple: you can focus on writing tests, and the snapshot
testing library will take care of the expected values automatically.</p><p>What does this look like in practice? Here&#39;s a snapshot test:</p><pre><code class="not-prose language-gleam hljs" data-lang="gleam">// In these examples we&#39;ll use the birdie library.
// You can add it to a gleam project by running
// `gleam add birdie --dev`
import birdie

pub fn help_text_test() {
  cli.help_text()
  |&gt; birdie.snap(title: &quot;testing the help text&quot;)
}
</code></pre><p>The function under test is still the same, but this time we&#39;re passing its
result to the <code>birdie.snap</code> function (don&#39;t worry about the title for now,
we&#39;ll get to that later).</p><p>This looks a bit magical: the expected value is nowhere to be seen, so how can
the library know when the test should fail? What happens if we run the test?
Let&#39;s try it!</p><div><pre><code data-highlighted='yes' class='not-prose language-shell'><span class='hljs-comment'>> gleam test</span>

<span class='hljs-shell-error'>panic</span> test/example_test.gleam:9
 <span class='hljs-shell-info'>test</span>: example_test.usage_text_test
 <span class='hljs-shell-info'>info</span>: Birdie snapshot test failed

Finished in 0.006 seconds
<span class='hljs-shell-error'>1 tests, 1 failures</span></code>
</pre></div><p>Not that exciting, the test is failing.
But we&#39;ll also see some new output along the failing test, this is where the
magic happens:</p><div><pre><code data-highlighted='yes' class='not-prose language-shell'>── new snapshot ────────────────────────────────────────────
  <span class='hljs-shell-info'>title</span>: testing the help text
  <span class='hljs-shell-info'>hint</span>: <span class='hljs-shell-warning'>run `gleam run -m birdie` to review the snapshots</span>
────────┬───────────────────────────────────────────────────
      <span class='hljs-shell-new'>1 + usage: lucysay [-m message] [-f file]
      2 +
      3 +  -m, --message  the message to be printed
      4 +  -f, --file     a file to read the message from
      5 +  -h, --help     show this help text</span>
────────┴───────────────────────────────────────────────────</code></pre></div><p>As the test fails it shows us the actual output produced by the function.
If we read the hint we realise that a human need to be in the loop, we have to
<em>review</em> the snapshot.
Let&#39;s follow the library&#39;s hint and review it:</p><div><pre><code data-highlighted='yes' class='not-prose language-shell'><span class='hljs-comment'>> gleam run -m birdie</span>

Reviewing <span class='hljs-shell-warning'>1st</span> out of <span class='hljs-shell-warning'>1</span>

── new snapshot ────────────────────────────────────────────
  <span class='hljs-shell-info'>title</span>: testing the help text
  <span class='hljs-shell-info'>file</span>: ./test/cli.gleam
────────┬───────────────────────────────────────────────────
       <span class='hljs-comment'>... here you'll see the snapshot from earlier</span>
────────┴───────────────────────────────────────────────────

  <span class='hljs-shell-new'>a</span> accept     accept the new snapshot
  <span class='hljs-shell-error'>r</span> reject     reject the new snapshot
  <span class='hljs-shell-warning'>s</span> skip       skip the snapshot for now
  <span class='hljs-shell-info'>d</span> hide diff  toggle snapshot diff</code></pre></div><p>We can read the content and see that it is exactly what we want, listing all the
options, and with no typos.
We accept the snapshot.
Now every time we run the tests, they will succeed… given the output of the
function doesn&#39;t change.</p><p>What&#39;s happening under the hood is unremarkably simple: the snapshot testing
library, once we accept the snapshot, saves its content to a file and checks
that the function will always produce that value.
If the output changes, the test will fail and we&#39;ll have to review the snapshot
again.</p><p>You can actually try the whole workflow for yourself here, just follow the hints
and type away!</p><div><div id="terminal"></div>
<script src="/js/birdie_terminal.js" type="module"></script></div></section><section class="stack"><h3 id="It&#39;s-like-VCS-for-your-tests">It&#39;s like VCS for your tests</h3><p>The nice upside about dealing with changing assertions is that the snapshot
testing library can be incredibly helpful when something changes.
For example, <a href="https://github.com/giacomocavalieri/birdie"><code>birdie</code></a> (the library
I&#39;m using here) will show you an informative diff view, much like a version
control system:</p><div><pre><code data-highlighted='yes' class='not-prose language-shell'>── mismatched snapshot ─────────────────────────────────────
  <span class='hljs-shell-info'>title</span>: testing the help text
  <span class='hljs-shell-info'>hint</span>: <span class='hljs-shell-warning'>run `gleam run -m birdie` to review the snapshots</span>
────────┬───────────────────────────────────────────────────
 <span class='hljs-shell-error'>1      - usage: lucysay [-m message] [-f file]</span>
      <span class='hljs-shell-new'>1 + usage: lucysay [-m message]</span>
      <span class='hljs-shell-new'>2 +   prints a cute message to standard output</span>
      <span class='hljs-comment'>3</span> │
      <span class='hljs-comment'>4</span> |  <span class='hljs-comment'>-m, --message  the message to be printed</span>
 <span class='hljs-shell-error'>4      -  -f, --file     a file to read the message from</span>
      <span class='hljs-comment'>5</span> |  <span class='hljs-comment'>-h, --help     show this help text</span>
────────┴───────────────────────────────────────────────────</code></pre></div><p>This is a really nice developer experience, we can see at a glance what has
changed and review it. And the best thing is we&#39;ve already been successfully
using this workflow for years with version control systems like <code>git</code> and
<a href="https://www.jj-vcs.dev/latest/"><code>jj</code></a>.
We know how all of this works, it feels familiar:</p><ul><li><section class="stack"><p>Something has changed, so it needs a review</p></section></li><li><section class="stack"><p>It looks ok, we can accept it and go on with our day</p></section></li><li><section class="stack"><p>It looks bad, we have to figure out if the change is wanted at all, or what
the cause of the bug might be</p></section></li></ul><p>Nowhere in this process we had to go through the assertions we had and update
them manually.
We can finally start focusing on our tests without being slowed down by managing
explicit assertions.</p></section><section class="stack"><h2 id="But-what-about-non-strings">But what about non-strings?</h2><p>I hear you. With my first example I have cheated a bit: the function we were
testing already produces a string that can be easily snapshotted and diffed.
But the functions we want to test in the real world rarely do that!
We might have to deal with lists, dictionaries, complex objects, strange
collections of data.
What then?</p><p><em>Turn them into strings.</em></p><p>Do we have to come up with a <code>to_string</code> function for each piece of data we want
to test?</p><p><em>Yes! And that&#39;s good actually!</em></p><p>It&#39;s easy to fall victim to the idea of turning each piece of data into a string
using some magic one-size-fit-all <code>to_string</code> function.
But being intentional about the shape of the data is what actually makes or
breaks snapshot testing.
Working with the Gleam compiler I ran into a great example of how much of a
difference a good snapshot test can actually make.</p><p>The Gleam compiler is a big piece of software written in Rust, it&#39;s also quite
thoroughly tested with over 5000 unit tests.
More than 3000 are actually snapshot tests (so if you&#39;re wondering if snapshot
testing can actually work in big numbers… it absolutely can)!</p><p>The piece of the Gleam codebase I will be focusing on is the Language Server
implementation.
I was looking at some snapshot tests meaning to check that hovering tooltips
actually worked.</p><blockquote class="stack"><p>The Language Server Protocol allows to display little tooltips when hovering
over specific portions of code. It&#39;s what shows you the documentation of a
function once you go over it with your cursor; or what shows you the inferred
type of a variable.
It&#39;s really useful, so we have to make sure we&#39;re displaying the correct
information and, crucially, that it is position correctly over the hovered
element.</p></blockquote><p>The Language Server produces some complex data structure with all the
information needed to render the tooltip by the IDE, that&#39;s what we will be
testing.
What we ended up doing at first, for lack of better ideas, is we snapshotted
the entire data structure turning it into a string using a default display
function. This is the test:</p><pre><code class="not-prose language-gleam hljs" data-lang="gleam">pub fn hovering_variable_test() {
  hover(over: find_position_of(&quot;a_variable&quot;), code: &quot;
    pub fn main() -&gt; Nil {
      let a_variable = 11
      Nil
    }
  &quot;)
  |&gt; hover_data_to_string
  |&gt; birdie.snap(title: &quot;hovering over a variable shows its type&quot;)
}
</code></pre><p>And here&#39;s what the snapshot would look like:</p><div><pre><code data-highlighted='yes' class='not-prose language-shell'>── new snapshot ────────────────────────────────────────────
  <span class='hljs-shell-info'>title</span>: hovering over a variable shows its type
  <span class='hljs-shell-info'>hint</span>: <span class='hljs-shell-warning'>run `gleam run -m birdie` to review the snapshots</span>
────────┬───────────────────────────────────────────────────
      <span class='hljs-shell-new'>1 + Hover(
      2 +   range: Some(Range(start: 24, end: 33)),
      3 +   contents: Scalar(
      4 +     String("```gleam\nInt\n```"),
      5 +   ),
      6 + )</span>
────────┴───────────────────────────────────────────────────</code></pre></div><p>Let me ask you: is this a good snapshot test?
It certainly contains all the information we care about, and it&#39;s plenty enough
to figure out if the implementation is correct.</p><p><em>But does it make easy to see the implementation is correct?</em></p><p>The range over which we display the tooltip might be wrong, and I wouldn&#39;t be
any wiser!
What I need to do is to painfully go and count the bytes in the original string
to make sure it is actually hovering the whole.
We&#39;ve replaced a painful unit test assertion with a painful to review snapshot!</p><p>When figuring out how to produce a snapshot putting care into its string format
is crucial to make testing simple and fun.
In this example, this is the look I ended up implementing:</p><div><pre><code data-highlighted='yes' class='not-prose language-shell'>── new snapshot ────────────────────────────────────────────
  <span class='hljs-shell-info'>title</span>: hovering over a variable shows its type
  <span class='hljs-shell-info'>hint</span>: <span class='hljs-shell-warning'>run `gleam run -m birdie` to review the snapshots</span>
────────┬───────────────────────────────────────────────────
      <span class='hljs-shell-new'>1 + pub fn main() -> Nil {
      2 +   let a_variable = 11
      3 +       ↑▔▔▔▔▔▔▔▔▔
      4 +   Nil
      6 + }
      5 +
      6 + ----- Hover content:
      7 + ```gleam
      8 + Int
      9 + ```</span>
────────┴───────────────────────────────────────────────────</code></pre></div><p>This is what I call a fun snapshot.
Looking at it we can see at a glance that the tooltip is perfectly aligned with
the variable being hovered, and its content is also rendered nicely below.</p><p>I cannot understate how much time having nice-to-read snapshots like this one
has saved me, Louis, and Surya when reviewing new code being contributed to the
Gleam compiler.
Heck, I&#39;d go so far to say it&#39;s actually fun to write tests and be confronted
with such nice, and visual output!</p></section><section class="stack"><h2 id="Your-imagination&#39;s-the-limit">Your imagination&#39;s the limit</h2><p>Hopefully, now you can get a sense for how powerful and malleable this can
actually be.
Ever since publishing my own snapshot testing library, I&#39;ve been amazed by the
creativity with which people have used it.</p></section><section class="stack"><h3 id="Testing-tricky-math-made-easy">Testing tricky math made easy</h3><p>This was shown to me by Hayleigh, a dear friend working on a
<a href="https://lustre.build">cool frontend framework</a>, as she was playing around with
building an animation library to create cool animations for the web.</p><div><div id="curve"></div>
<script src="/js/curve_in_out.js" type="module"></script></div><blockquote class="stack"><p>If you&#39;ve done any web development you might already be familiar with the
likes of <code>ease-in-out</code>, <code>ease-in</code>, <code>cubic-bezier</code>, and such.
They all are different interpolation functions!</p><div><style>
.moving-cube {
  width: var(--s2);
  height: var(--s2);
  background-color: var(--main-color);
  animation: start-to-end 2.5s ease-in infinite;
}
.paused-cube {
  animation-play-state: paused;
}

@keyframes start-to-end {
  0%, 100% {
    margin-inline-start: 0px;
    width: var(--s2);
  }
  25% {
    width: calc(var(--s2) * 1.1);
  }
  50% {
    margin-inline-start: calc(100% - var(--s2));
    width: var(--s2);
  }
}
</style>
<section class="stack-s">
  <ul class="stack-s">
    <li>
      <p><code>ease-in-out</code></p>
      <div class='moving-cube' style='animation-timing-function: ease-in-out'></div>
    </li>
    <li>
      <p><code>ease-in</code></p>
      <div class='moving-cube' style='animation-timing-function: ease-in'></div>
    </li>
    <li>
      <p>
        <code>cubic-bezier(1, 0, 0.5, 1)</code>, tweaking the parameters you
        can get some fun spring-like movements
      </p>
      <div class='moving-cube' style='animation-timing-function: cubic-bezier(1,0,0.5,1)'></div>
    </li>
  </ul>
  <button onclick="toggle(this)">Pause animation</button>
</section>
<script>
 function toggle(button) {
   if (button.innerText === "Start animation") {
      button.innerText = "Pause animation"
   } else {
      button.innerText = "Start animation"
   }
   for (element of document.getElementsByClassName('moving-cube')) {
     element.classList.toggle('paused-cube');
   }
 }
</script></div></blockquote><p>TODO)) CAMBIARE NON MI SUONA BENE
An animation relies on being able to define some interpolation function.
describing how to move objects</p><p>At the end of the day, an interpolation function is something pretty
straightforward: given the start position, end position, and a point;
return its interpolated value.</p><pre><code class="not-prose language-gleam hljs" data-lang="gleam">pub fn ease_in(
  point: Float,
  from start: Float,
  to end: Float
) -&gt; Float {
  todo as &quot;tricky math in here...&quot;
}
</code></pre><p>The math in there can be quite tricky and easy to get wrong, so of course we
have to test it!
If we were to write a regular unit test we might check the expected output for
some known values:</p><pre><code class="not-prose language-gleam hljs" data-lang="gleam">pub fn ease_in_test() {
  assert ease_in(0.0, from: 0.0, to: 1.0) == 0.0
  assert ease_in(0.5, from: 0.0, to: 1.0) == 0.6
  assert ease_in(0.7, from: 0.0, to: 1.0) == 0.8
}
</code></pre><p>But is this a good test? Imagine someone saw your cool library and decided to
contribute with a new animation <code>ease-in-out</code>, they also added new tests, how
nice of them!</p><pre><code class="not-prose language-gleam hljs" data-lang="gleam">pub fn ease_in_out_test() {
  assert ease_in_out(0.0, from: 0.0, to: 1.0) == 0.0
  assert ease_in_out(0.5, from: 0.0, to: 1.0) == 0.7
  assert ease_in_out(0.7, from: 0.0, to: 1.0) == 0.9
}
</code></pre><p>Does looking at this test give you confidence that the implementation of
<code>ease_in_out</code> is correct? The answer is no!
<code>ease_in_out</code> might be full of subtle bugs, those asserted numbers might as well
be random, and I wouldn&#39;t be any wiser.
This test is <em>not telling me anything</em> about the correctness of the tested
function.</p></section><section class="stack"><h3 id="Chess-engines-like-you&#39;ve-never-seen-them">Chess engines like you&#39;ve never seen them</h3><blockquote class="stack"><p>Note on old systems and using snapshots to change them without breaking the
observable behaviour</p></blockquote></section></main></body></html>